# 多态

## 一. 概述

**什么是多态**

- 同类型的对象, 执行同一个行为, 会表现出**不同的行为特征**

**多态的常见形式**

- 父类类型 对象名称 = new 子类构造器;
- 接口 对象名称 = new 实现类构造器;

**多态中成员访问特点**

- **方法调用: 编译看左边, 运行看右边**
- **变量调用: 编译看左边, 运行也看左边**.(**多态侧重行为多态**)

**多态的前提**

- 有继承/实现关系; 有父类引用指向子类对象; 有方法重写





## 二. 多态的优势

- 在多态形式下, 右边对象可以实现解耦合, 便于扩展和维护

```java
Animal a = new Dog();
a.run();//后续业务行为随对象而变, 后续代码无需维护
```

- 定义方法时候, 使用父类型作为参数, 该方法就可以接受这父类的一切子类对象, 体现出多态的拓展性与遍历

```java
/**
    要求: 所有动物都可以进来比赛
 */
public static void contest(Animal a){
    System.out.println("start...");
    a.run();
    System.out.println("finish...");
}
```

**多态下会产生一个问题**

- 多态不能使用子类独有的功能





## 三. 多态下引用数据类型的类型转换

**自动类型转换(从子到父)**: 子类对象赋值给父类类型的变量指向

**强制类型转换(由父到子):**

- 此时必须进行强制类型转换: 子类 对象变量 = (子类)父类类型的变量
- 作用: 可以解决多态下的劣势, 可以实现调用子类独有的功能

- **注意: 如果转换后的类型和对象真实类型不是同一种类型, 那么在转换时就会出现ClassCastException**

**JAVA建议强制转换前使用instance判断当前对象的真实类型, 再进行强制转换**

- 变量名 instanceof 真实类型

```java
Animal b = new Tortoise();

if(b instanceof Tortoise){
    Tortoise t1 = (Tortoise)b;
    t1.layEggs();
}else if(b instanceof Dog){
    Dog d1 = (Dog)b;
    d.lookDoor();
}
```

## 四. 多态案例

